# -*- coding: utf-8 -*-
"""svf_fisheye_v1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JT4J5g4ov9fEG54ul5B5Rr6M0-QzeOZg
"""

#V1.0
import os
import json
import requests
from PIL import Image
from io import BytesIO
import cv2
import numpy as np
import re
from datetime import datetime
import matplotlib.pyplot as plt



os.environ['GOOGLE_MAPS_API_KEY'] = 'AIzaSyBYQgyZQu_SqWFVkBWH2kWjruhEsYvzvu8'

API_KEY = os.environ.get('GOOGLE_MAPS_API_KEY')

if API_KEY:
    print("API Key loaded successfully from environment variable in Colab.")
else:
    print("Error: Google Maps API Key not set as an environment variable in Colab!")



# Function to extract latitude and longitude from the JSON string
def extract_lat_lng_from_json(json_string):
    try:
        data = json.loads(json_string)
        latitude = data.get('lat')
        longitude = data.get('lng')
        return latitude, longitude
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON: {e}")
        return None, None


# Function to fetch a Street View image using Google Maps API
def get_street_view_image(lat, lon, heading, pitch, size, fov, api_key):
    base_url = "https://maps.googleapis.com/maps/api/streetview"
    params = {
        'size': size,
        'location': f"{lat},{lon}",
        'fov': fov,
        'heading': heading,
        'pitch': pitch,
        'key': api_key
    }
    response = requests.get(base_url, params=params)

    # Check if the response is valid
    if response.status_code != 200:
        raise Exception(f"Error fetching image: {response.status_code}, {response.text}")

    # Verify if the content is an image
    content_type = response.headers.get('Content-Type', '')
    if 'image' not in content_type:
        raise Exception(f"Invalid content type received: {content_type}, {response.text}")

    return Image.open(BytesIO(response.content))

# Function to capture images for panorama stitching
def capture_images(lat, lon, headings, pitches, size, fov, api_key):
    images = []
    for pitch in pitches:
        for heading in headings:
            img = get_street_view_image(lat, lon, heading, pitch, size, fov, api_key)
            images.append(np.array(img))
    return images

# Function to preprocess images
def preprocess_image(image, target_size=(512, 1024)):
    # Convert to RGB
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Resize while maintaining aspect ratio
    h, w = image.shape[:2]
    scale = target_size[0] / float(h)
    resized_image = cv2.resize(image, (int(w * scale), target_size[0]), interpolation=cv2.INTER_AREA)

    # Normalize pixel values
    normalized_image = resized_image / 255.0

    # Apply Gaussian Blur to reduce noise
    blurred_image = cv2.GaussianBlur(normalized_image, (5, 5), 0)

    return blurred_image

# Function to preprocess all captured images
def preprocess_images(images):
    preprocessed_images = []
    for img in images:
        preprocessed_img = preprocess_image(img)
        preprocessed_images.append((preprocessed_img * 255).astype(np.uint8))
    return preprocessed_images

# Function to create a panorama using OpenCV
def create_panorama(images):
    stitcher = cv2.Stitcher_create() if int(cv2.__version__.split('.')[0]) >= 4 else cv2.createStitcher()
    status, panorama = stitcher.stitch(images)
    return status, panorama

# Function to generate a fisheye projection from a panorama
def create_fisheye_image(panorama, fisheye_diameter):
    pano_image = cv2.cvtColor(panorama, cv2.COLOR_BGR2RGB)
    fisheye_radius = fisheye_diameter // 2
    fisheye_image_full = np.zeros((fisheye_diameter, fisheye_diameter, 3), dtype=np.uint8)

    for y_fish in range(fisheye_diameter):
        for x_fish in range(fisheye_diameter):
            dx = x_fish - fisheye_radius
            dy = y_fish - fisheye_radius
            r = np.sqrt(dx**2 + dy**2)
            if r > fisheye_radius:
                continue  # Outside the fisheye circle

            theta = np.arctan2(dy, dx)  # Azimuthal angle
            '''ADD or REMOVE  " 2* " before np.pi , if half down is black or not'''
            phi = np.pi * r / fisheye_radius  # Zenith angle, adjusted for full 360Â°

            # Map polar angles to panoramic coordinates
            pano_x = int((theta + np.pi) / (2 * np.pi) * pano_image.shape[1])
            pano_y = int((phi / (2 * np.pi)) * pano_image.shape[0])  # Full vertical mapping

            # Ensure coordinates are within bounds
            pano_x = np.clip(pano_x, 0, pano_image.shape[1] - 1)
            pano_y = np.clip(pano_y, 0, pano_image.shape[0] - 1)

            # Assign pixel value
            fisheye_image_full[y_fish, x_fish] = pano_image[pano_y, pano_x]

    return fisheye_image_full

# Main function to run the workflow
def main():
    try:


        # 1. Get latitude and longitude from the JSON string
        json_data = '{"lat": "45.0624562", "lng": "7.6624844", "timestamp": "Sun Apr  6 15:48:02\u00a0UTC 2025"}'
        latitude, longitude = extract_lat_lng_from_json(json_data)
        if not latitude or not longitude:
            raise ValueError("Could not extract latitude and longitude from JSON.")
        print(f"Latitude: {latitude}, Longitude: {longitude}")


        API_KEY = os.environ.get('GOOGLE_MAPS_API_KEY')
        if not API_KEY:
            raise ValueError("Google Maps API Key environment variable not found!")
        size = "640x640"
        fov = 100
        num_horizontal = 12
        headings = range(0, 360, 360 // num_horizontal)
        pitches = [40]

        # Capture and preprocess images
        images = capture_images(latitude, longitude, headings, pitches, size, fov, API_KEY)
        preprocessed_images = preprocess_images(images)

        # Create panorama
        status, panorama = create_panorama(preprocessed_images)
        if status == cv2.Stitcher_OK:
            # Save panorama
            timestamp = datetime.now().strftime("%m%d_%H%M%S")
            panorama_filename = f'sph_{timestamp}.jpg'
            cv2.imwrite(panorama_filename, panorama)
            print(f"Spherical panorama saved as '{panorama_filename}'")

            # Create fisheye image
            fisheye_diameter = 1000
            fisheye_image = create_fisheye_image(panorama, fisheye_diameter)

            # Save and display fisheye image
            fisheye_filename = f'fish_{timestamp}.jpg'
            cv2.imwrite(fisheye_filename, cv2.cvtColor(fisheye_image, cv2.COLOR_RGB2BGR))
            print(f"Fisheye image saved as '{fisheye_filename}'")

            # Display both images side by side
            plt.figure(figsize=(15, 7))
            plt.subplot(1, 2, 1)
            plt.imshow(cv2.cvtColor(panorama, cv2.COLOR_BGR2RGB))
            plt.axis("off")
            plt.title("Spherical Panorama")

            plt.subplot(1, 2, 2)
            plt.imshow(fisheye_image)
            plt.axis("off")
            plt.title("Fisheye Image")

            plt.show()
        else:
            print("Error during stitching:", status)
    except Exception as e:
        print("An error occurred:", e)

# Run the main function
if __name__ == "__main__":
    main()